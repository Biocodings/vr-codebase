#!/usr/bin/env perl
#
# Author: petr.danecek@sanger
#

use strict;
use warnings;
use Carp;
use Vcf;

my $opts = parse_params();
compare_vcfs($opts);

exit;

#--------------------------------

sub error
{
    my (@msg) = @_;
    if ( scalar @msg )
    {
        croak @msg;
    }
    die
        "About: Compare bgzipped and tabix indexed VCF files. (E.g. bgzip file.vcf; tabix -p vcf file.vcf.gz)\n",
        "Usage: compare-vcf [OPTIONS] file1.vcf file2.vcf ...\n",
        "Options:\n",
        "   -c, --chromosomes <list|file>       Process the given chromosomes (comma-separated list or one chromosome per line in a file).\n",
        "   -d, --debug                         Debugging information\n",
        "   -H, --cmp-haplotypes                Compare haplotypes, not only positions\n",
        "   -h, -?, --help                      This help message.\n",
        "   -w, --win <int>                     In repetitive sequences, the same indel can be called at different positions. Consider\n",
        "                                           records this far apart as matching (be it a SNP or an indel).\n",
        "\n";
}


sub parse_params
{
    my $opts = { positions=>0 };
    while (my $arg=shift(@ARGV))
    {
        if ( $arg eq '-c' || $arg eq '--chromosomes' ) { $$opts{chromosomes}=shift(@ARGV); next; }
        if ( $arg eq '-H' || $arg eq '--cmp-haplotypes' ) { $$opts{cmp_haplotypes}=1; next; }
        if ( $arg eq '-d' || $arg eq '--debug' ) { $$opts{debug}=1; next; }
        if ( $arg eq '-w' || $arg eq '--win' ) { $$opts{win}=shift(@ARGV); next; }
        if ( -e $arg ) { push @{$$opts{files}}, $arg; next }
        if ( $arg eq '-?' || $arg eq '-h' || $arg eq '--help' ) { error(); }
        error("Unknown parameter or non-existent file \"$arg\". Run -h for help.\n");
    }
    if ( !exists($$opts{files}) ) { error("What files should be compared?\n") }
    return $opts;
}

sub read_chrom_list
{
    my ($fname) = @_;
    my @chroms;
    if ( -e $fname )
    {
        open(my $chrms,'<',$fname) or error("$fname: $!");
        while (my $line=<$chrms>)
        {
            chomp($line);
            push @chroms, $line;
        }
        close($chrms);
    }
    else
    {
        @chroms = split(/,/,$fname);
    }
    return (@chroms);
}

sub compare_vcfs
{
    my ($opts) = @_;

    $$opts{match} = {};
    $$opts{hapls} = {};

    # Open the VCF files and initialize the list of chromosomes
    my @vcfs;
    my (@chroms,%has_chrom);
    if ( exists($$opts{chromosomes}) ) { @chroms = read_chrom_list($$opts{chromosomes}); }

    for my $file (@{$$opts{files}})
    {
        my $vcf = Vcf->new(file=>$file);
        $vcf->parse_header();
        $vcf->close();
        $$vcf{nread} = 0;
        push @vcfs, $vcf;

        # Update the list of known chromosomes
        if ( !exists($$opts{chromosomes}) )
        {
            my $chrms = $vcf->get_chromosomes();
            for my $chr (@$chrms)
            {
                if ( exists($has_chrom{$chr}) ) { next; }
                $has_chrom{$chr} = 1;
                push @chroms, $chr;
            }
        }
    }

    # Go through all the files simultaneously and get the stats.
    for my $chr (@chroms)
    {
        # Open files
        for my $vcf (@vcfs)
        {
            delete($$vcf{last_line});
            $vcf->open(region=>$chr,parse_header=>1);
            delete($$vcf{eof});
        }
        do_chrm_stats($opts,\@vcfs);
    }

    report_stats($opts,\@vcfs);

    for my $vcf (@vcfs)
    {
        if ( !$$vcf{nread} ) { warn("Warning: Read 0 lines from $$vcf{file}, the tabix index may be broken.\n"); }
    }
}

sub report_stats
{
    my ($opts,$vcfs) = @_;

    if ( $$opts{debug} )
    {
        use Data::Dumper; print Dumper($$opts{match});
    }

    my (@counts,%totals);
    while (my ($key,$num) = each %{$$opts{match}})
    {
        my @files = split(/\s+/,$key);
        for my $file (@files)
        {
            $totals{$file} += $num;
        }
        push @counts, {count=>$num, files=>[@files]};
    }

    print "Number of sites found only in\n";
    for my $rec (sort {$$a{count}<=>$$b{count}} @counts)
    {
        my $num   = $$rec{count};
        my $files = $$rec{files};

        print "\t$num";
        for my $file (@$files)
        {
            printf "\t$file (%.1f%%)", $num*100./$totals{$file};
        }
        print "\n";
    }

    my $out;
    for my $vcf (@$vcfs)
    {
        if ( !exists($totals{$$vcf{file}}) ) { $totals{$$vcf{file}}=0; }
        if ( $totals{$$vcf{file}} == $$vcf{nread} ) { next; }

        my $diff  = $$vcf{nread}-$totals{$$vcf{file}};
        my $reported = $totals{$$vcf{file}};
        my $total = $$vcf{nread};
        $out .= sprintf "\t%d (%.1f%%) .. read %d, reported %d\t%s\n", $diff,$diff*100./$total,$total,$reported,$$vcf{file};
    }
    if ( $out )
    {
        print "Number of sites lost due to grouping\n";
        print $out;
    }

    if ( $$opts{cmp_haplotypes} )
    {
        print "Haplotype comparison:\n";
        printf "\t%d .. sites compared\n", $$opts{hapls_ncmp};
        for my $id (keys %{$$opts{hapls}})
        {
            print "$id:\n";
            printf "\t%d .. non-empty sites\n", $$opts{hapls}{$id}{ncmp} ? $$opts{hapls}{$id}{ncmp} : 0;
            printf "\t%d .. matching sites\n", $$opts{hapls}{$id}{match} ? $$opts{hapls}{$id}{match} : 0;
            printf "\t\t%d .. phased matches\n", $$opts{hapls}{$id}{phase_match} ? $$opts{hapls}{$id}{phase_match} : 0;
            printf "\t\t%d .. misphased matches\n", $$opts{hapls}{$id}{phase_mismatch} ? $$opts{hapls}{$id}{phase_mismatch} : 0;
        }
    }
}

sub do_chrm_stats
{
    my ($opts,$vcfs) = @_;

    my $nvcfs = scalar @$vcfs;
    my $debug = $$opts{debug} ? 1 : 0;
    my $match = $$opts{match};
    my $win   = $$opts{win} ? $$opts{win} : 0;
    while (1)
    {
        my $grp = read_next_group($vcfs,$win);
        if ( !$grp || !scalar @$grp ) { last }

        if ( $debug )
        {
            print "Group:\n";
            for my $rec (@$grp) { print "$$rec{chr}\t$$rec{pos}\t$$rec{vcf}{file}\n"; }
            print "\n";
        }

        my %files;
        for my $rec (@$grp)
        {
            $files{$$rec{vcf}{file}} = 1;
        }
        my $key = join(' ',sort(keys %files));
        $$match{$key}++;

        if ( $$opts{cmp_haplotypes} )
        {
            # Check that in the group there is one record for each file
            my $present = 0;
            for (my $i=0; $i<@$grp; $i++)
            {
                if ( $$grp[$i]{vcf} ne $$vcfs[$i] ) { last; }
                $present++;
            }
            if ( $present==$nvcfs && scalar @$grp==$nvcfs )
            {
                cmp_haplotypes($opts,$grp);
            }
        }
    }
}


sub cmp_haplotypes
{
    my ($opts,$grp) = @_;
    my $nrecs = @$grp;
    my $hapls = $$opts{hapls};

    # Break the VCF lines into hashes (required by parse_haplotype)
    for my $grp_rec (@$grp)
    {
        $$grp_rec{rec} = $$grp_rec{vcf}->next_data_hash($$grp_rec{line});
    }

    for my $id (keys %{$$grp[0]{rec}{gtypes}})
    {
        my ($als1,$seps1,$is_phased1,$is_empty1) = $$grp[0]{vcf}->parse_haplotype($$grp[0]{rec},$id);
        if ( $is_empty1 ) 
        {
            $$hapls{$id}{not_avail}++;
            next;
        }
        my @sorted_als1 = sort @$als1;
        my $nploid = scalar @sorted_als1;

        my $ncmp  = 1;
        my $match = 1;
        my $phase = $is_phased1 ? 1 : -1;  # 1 .. they are phased and the phase agrees; 0 phased and the phase disagrees; -1 not phased
        for (my $i=1; $i<$nrecs; $i++)
        {
            my ($als2,$seps2,$is_phased2,$is_empty2) = $$grp[$i]{vcf}->parse_haplotype($$grp[$i]{rec},$id);
            if ( $is_empty2 ) { $match = 0; last; }
            if ( !$is_phased2 ) { $phase=-1; }
            
            # Evaluate different number of alleles as mismatch (C vs C/C)
            if ( scalar @$als1 != scalar @$als2 ) { $match=0; $ncmp++; next; }
            
            my @sorted_als2 = sort @$als2;
            for (my $ial=0; $ial<$nploid; $ial++)
            {
                if ( $sorted_als1[$ial] ne $sorted_als2[$ial] ) { $match=0; last; }
            }

            # They match, check also if their phase agrees
            if ( $phase==1 && $is_phased1 && $is_phased2 )
            {
                for (my $ial=0; $ial<$nploid; $ial++)
                {
                    if ( $$als1[$ial] ne $$als2[$ial] ) { $phase=0; last; }
                }
            }
            $ncmp++;
        }
        if ( $ncmp!=$nrecs )
        {
            $$hapls{$id}{not_avail}++;
            next;
        }
        if ($match) 
        { 
            $$hapls{$id}{match}++; 
            if ( $phase==1 ) { $$hapls{$id}{phase_match}++ }
            elsif ( $phase==0 ) { $$hapls{$id}{phase_mismatch}++ }
        }
        $$hapls{$id}{ncmp}++;
    }
    $$opts{hapls_ncmp}++;
}


sub read_next_group
{
    my ($vcfs,$win) = @_;

    my @grp;
    my $prev_vcf;
    my $start;

    while (1)
    {
        my $min_vcf = get_min_position($vcfs);
        if ( !$min_vcf ) { last; }
        if ( $prev_vcf && $prev_vcf eq $$min_vcf{buf}[0] ) { last; }
        $prev_vcf = $$min_vcf{buf}[0];

        if ( !$start or $start+$win >= $$min_vcf{buf}[0]{pos} )
        {
            my $rec = shift(@{$$min_vcf{buf}});
            push @grp,$rec;

            $start = $$rec{pos};
            next; 
        }
    }
    return \@grp;
}

sub get_min_position
{
    my ($vcfs) = @_;

    my ($min_pos,$min_vcf);
    for my $vcf (@$vcfs)
    {
        # Check if there is a line in the buffer, if not, read. If still empty, the file reached eof
        if ( !$$vcf{buf} or !scalar @{$$vcf{buf}} ) { read_line($vcf); }
        if ( !$$vcf{buf} or !scalar @{$$vcf{buf}} ) { next; }

        my $line = $$vcf{buf}[0];

        # Designate this position as the minimum of all the files if:
        # .. is this the first file?
        if ( !$min_pos )
        {
            $min_pos = $$line{pos};
            $min_vcf = $vcf;
            next;
        }

        # .. has this file lower position?
        if ( $min_pos>$$line{pos} )
        {
            $min_pos = $$line{pos};
            $min_vcf = $vcf;
            next;
        }
    }
    return $min_vcf;
}

sub read_line
{
    my ($vcf) = @_;

    if ( $$vcf{eof} ) { return; }

    my $line = $vcf->next_line();
    if ( !$line )
    {
        $$vcf{eof} = 1;
        return;
    }

    $$vcf{nread}++;

    if ( !($line=~/^(\S+)\t(\S+)\t\S+\t(\S+)\t(\S+)/) ) { error("Could not parse the line: [$line]\n"); }
    my $chr = $1;
    my $pos = $2;
    my $ref = $3;
    my $alt = $4;
    if ( $$vcf{buf} && @{$$vcf{buf}} )
    {
        my $prev = $$vcf{buf}[-1];
        if ( $$prev{pos} == $pos ) { warn("Position $chr:$pos appeared twice in $$vcf{file}\n"); }
    }

    push @{$$vcf{buf}}, { chr=>$chr, pos=>$pos, ref=>$ref, alt=>$alt, line=>$line, vcf=>$vcf };
    return;
}

