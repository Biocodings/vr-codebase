#!/usr/bin/env perl
#
# support: pd3@sanger

use strict;
use warnings;
use Carp;
use Vcf;

my $opts = parse_params();
annotate($opts);

exit;

#--------------------------------

sub error
{
    my (@msg) = @_;
    if ( scalar @msg ) { confess @msg; }
    die
        "About: Add custom annotations to a VCF file. Requires tabix indexed file with annotations.\n",
        "   Currently annotates only the INFO column, but it will be extended on demand.\n",
        "Usage: cat in.vcf | vcf-annotate [OPTIONS] > out.vcf\n",
        "Options:\n",
        "   -a, --annotations <file.gz>         The tabix indexed file with the annotations: CHR\\tFROM[\\tTO][\\tVALUE]+.\n",
        "   -c, --columns <list>                The list of columns in the annotation file, e.g. CHROM,FROM,TO,-,INFO/STR,INFO/GN. The dash\n",
        "                                           in this example indicates that the third column should be ignored. If TO is not\n",
        "                                           present, it is assumed that TO equals to FROM.\n",
        "   -d, --description <file|string>     Header annotation, e.g. key=INFO,ID=HM2,Number=0,Type=Flag,Description='HapMap2 membership'.\n",
        "                                           The descriptions can be read from a file, one annotation per line.\n",
        "       --SnpCluster <count,win>        Set filter for clusters of 'count' or more SNPs within a run of 'win' bases.\n",
        "   -h, -?, --help                      This help message.\n",
        "Example:\n",
        "   zcat in.vcf.gz | vcf-annotate -a annotations.gz -d descriptions.txt | bgzip -c >out.vcf.gz \n",
        "Where descriptions.txt contains:\n",
        "   key=INFO,ID=GN,Number=1,Type=String,Description='Gene Name'\n",
        "   key=INFO,ID=STR,Number=1,Type=Integer,Description='Strand'\n",
        "\n";
}

sub parse_params
{
    my $opts = { args=>[$0, @ARGV] };
    while (defined(my $arg=shift(@ARGV)))
    {
        if ( $arg eq '-d' || $arg eq '--description' ) 
        { 
            my $desc = shift(@ARGV);
            if ( -e $desc )
            {
                open(my $fh,'<',$desc) or error("$desc: $!");
                while (my $line=<$fh>)
                {
                    if ( $line=~/^\s*$/ or $line=~/^#/ ) { next; }
                    chomp($line);
                    push @{$$opts{desc}}, $line;
                }
                close($fh);
            }
            else
            {
                push @{$$opts{desc}}, $desc; 
            }
            next;
        }
        if ( $arg eq '--SnpCluster' ) 
        {
            my $tmp = shift(@ARGV);
            ($$opts{SnpCluster_count},$$opts{SnpCluster_win}) = split(/,/,$tmp);
            # Simple sanity check
            if ( $$opts{SnpCluster_count}>$$opts{SnpCluster_win} ) 
            { 
                error("Did you really mean --SnpCluster $tmp or --SnpCluster $tmp $$opts{SnpCluster_win},$$opts{SnpCluster_count}?"); 
            }
            $$opts{SnpCluster_buffer} = [];
            push @{$$opts{desc}}, "key=FILTER,ID=SnpCluster,Description='SNPs found in clusters (win=$$opts{SnpCluster_win},count=$$opts{SnpCluster_count})'";
            next;
        }
        if ( $arg eq '-c' || $arg eq '--columns' ) 
        { 
            my $cols = shift(@ARGV);
            $$opts{cols} = [ split(/,/,$cols) ];
            next; 
        }
        if ( $arg eq '-a' || $arg eq '--annotations' ) { $$opts{annotations} = shift(@ARGV); next }
        if ( $arg eq '-t' || $arg eq '--tag' ) { $$opts{tag} = shift(@ARGV); next }
        if ( $arg eq '-?' || $arg eq '-h' || $arg eq '--help' ) { error(); }
        if ( -e $arg ) { $$opts{file}=$arg; next; }
        error("Unknown parameter \"$arg\". Run -h for help.\n");
    }
    if ( !exists($$opts{SnpCluster_count}) )
    {
        if ( !exists($$opts{desc}) ) { error("Missing the -d or --SnpCluster option.\n") }
        if ( !exists($$opts{annotations}) ) { error("Missing the -a option.\n") }
    }
    return $opts;
}

# Convert text descriptions given on command line to hashes which will be 
#   passed to Vcf::add_header_line
sub parse_descriptions
{
    my ($descs) = @_;
    my @out;
    for my $str (@$descs)
    {
        my $desc = {};
        my $tmp = $str;
        while ($tmp)
        {
            my ($key,$value);
            if ( $tmp=~/^([^=]+)=["']([^\"]+)["']/ ) { $key=$1; $value=$2; }
            elsif ( $tmp=~/^([^=]+)=([^,"]+)/ && $1 eq 'Description' ) 
            {
                # The command line eats the quotes
                $key=$1; $value=$2.$';
                $$desc{$key} = $value;
                last;
            }
            elsif ( $tmp=~/^([^=]+)=([^,"]+)/ ) 
            { 
                $key=$1; $value=$2; 
            }
            else { error(qq[Could not parse the description: [$str]\n]); }
            $$desc{$key} = $value;

            $tmp = $';
            if ( $tmp=~/^,/ ) { $tmp = $'; }

        }
        if ( !exists($$desc{ID}) ) { error("No ID in description? [$str]\n"); }
        push @out, $desc;
    }
    return \@out;
}

# Create mapping from the annotation IDs to column indexes. The mapping is used
#   to determine which columns should be used from the annotation file. The
#   following structure is returned:
#       { 
#           CHROM => col_idx,
#           FROM  => col_idx,
#           TO    => col_idx,
#           annots => 
#           [
#               { col=>col_idx, id=>annot_id, vcf_col=>vcf_column, is_flag=>0 },
#           ]
#       }
#   If {annots}{is_flag} is nonzero, "annot_id" will be written to VCF instead of "annot_id=value".
#   Currently only one VCF column (INFO) is supported. 
#
sub parse_columns
{
    my ($cols,$descriptions) = @_;

    my %desc = ();
    my %out  = ( annots=>[] );

    if ( !defined $cols ) { return \%out; }

    for my $d (@$descriptions)
    {
        $desc{$$d{key}.'/'.$$d{ID}} = $d;
    }

    for (my $i=0; $i<@$cols; $i++)
    {
        my $col = $$cols[$i];

        if ( $col eq '-' ) { next; }
        elsif ( exists($desc{$col}) ) 
        {
            if ( !($col=~m{^(.+)/(.+)$}) ) { error("Could not parse the column [$col].\n"); }
            my $key = $1;
            my $id  = $2;
            my $rec = { col=>$i, id=>$id, vcf_col=>$key, is_flag=>($desc{$col}{Type} eq 'Flag' ? 1 : 0) };
            push @{$out{annots}}, $rec;
            if ( $key ne 'INFO' ) { error("TODO: other than INFO columns\n"); }
        }
        elsif ( $col eq 'CHROM' ) { $out{$col}=$i; }
        elsif ( $col eq 'FROM' ) { $out{$col}=$i; }
        elsif ( $col eq 'TO' ) { $out{$col}=$i; }
        else { error("Missing the -d parameter for the column [$col]\n"); }
    }
    if ( !exists($out{CHROM}) ) { $out{CHROM}=0; }
    if ( !exists($out{FROM}) ) { $out{FROM}=1; }
    if ( !exists($out{TO}) ) { $out{TO}=$out{FROM}; }
    return \%out;
}

sub annotate
{
    my ($opts) = @_;

    # Init the variables
    my $descs = parse_descriptions($$opts{desc});
    my $cols  = parse_columns($$opts{cols},$descs);

    # Open VCF file and add all required header lines
    my $vcf = $$opts{vcf} = exists($$opts{file}) ? Vcf->new(file=>$$opts{file}) : Vcf->new(fh=>\*STDIN);
    $vcf->parse_header();
    for my $desc (@$descs)
    {
        $vcf->add_header_line($desc,silent=>1);
    }
    $vcf->add_header_line({key=>'source',value=>join(' ',@{$$opts{args}})},append=>'timestamp');
    print $vcf->format_header();

    my $reader = Reader->new(file=>$$opts{annotations});

    my ($prev_chr,$prev_pos,$annot_from,$annot_to,$annot_line);
    my @annots = @{$$cols{annots}};


    # Process the file
    while (my $line = $vcf->next_line())
    {
        my @rec = split(/\t/,$line);
        my $chr = $rec[0];
        my $pos = $rec[1];
        chomp($rec[-1]);

        # Check if the current annotation reader has the right chromosome
        if ( !$prev_chr || $prev_chr ne $chr )
        {
            $reader->open(region=>$chr);
            undef $annot_line;
        }
        else
        {
            # Still on the same chromosome, check the order
            if ( $pos<$prev_pos ) { error("The VCF file not sorted, $chr:$pos comes after $prev_pos\n"); }
        }

        # Get the corresponding annotation, the order is guaranteed by tabix
        while (1)
        {
            if ( defined $annot_line && $annot_from<=$pos && $annot_to>=$pos ) 
            { 
                # The VCF matches the annotation
                last; 
            }

            $annot_line = $reader->next_line();
            if ( !defined $annot_line ) { last; }

            $annot_from = $$annot_line[ $$cols{FROM} ];
            $annot_to   = $$annot_line[ $$cols{TO} ];

            if ( $annot_from>$pos )
            {
                # The annotation file is ahead of VCF
                $reader->unread_line($annot_line);
                undef $annot_line;
                last;
            }
            # The VCF is ahead or it matches the annotation. The latter will be checked at 
            #   the beginning of this loop
        }

        # Is there a record in the annotation file which describes the VCF record $chr:$pos?
        if ( defined($annot_line) )
        {
            # Sanity check, this should be always true
            if ( $annot_from>$pos or $annot_to<$pos ) { error("FIXME: Annotation $chr:$annot_from-$annot_to vs VCF $chr:$pos??\n"); }

            # Existing annotations will be overwritten if they have the same name
            my %values = ();
            for my $info (@annots)
            {
                my $val = $$annot_line[$$info{col}];
                chomp($val);

                if ( $val eq '' or $val eq '.' ) { $val=undef; }       # Existing annotation should be removed
                elsif ( $$info{is_flag} )
                {
                    if ( $val ) { $val=''; }            # Flag annotation should be added
                    else { $val=undef; }                # Flag annotation should be removed
                }
                $values{$$info{id}} = $val;
            }

            $rec[7] = $vcf->add_info_field($rec[7],%values);
        }

        # Output the line
        output_line($opts,$chr,$pos,\@rec);

        $prev_chr = $chr;
        $prev_pos = $pos;
    }

    # Output any lines left in the buffer
    output_line($opts);
}


# Stage the lines and then apply filtering if requested, otherwise just print the line
sub output_line
{
    my ($opts,$chr,$pos,$line) = @_;

    # No filtering requested, print the line
    if ( !exists($$opts{SnpCluster_count}) )
    {
        print_line($line);
        return;
    }

    my $buffer = $$opts{SnpCluster_buffer};
    my $n = @$buffer;

    # The buffer is empty and the line contains only reference alleles, print directly
    if ( $n==0 && defined $line && $$line[4] eq '.' )
    {
        $$line[6] = $$opts{vcf}->add_filter($$line[6],'SnpCluster'=>0); 
        print_line($line);
        return;
    }

    # Store the line in buffer and check how many lines can be printed
    my $to;     # All the lines up to and including this index will be printed
    my $win = $$opts{SnpCluster_win};
    if ( defined $line )
    {
        my $is_ref = $$line[4] eq '.' ? 1 : 0; 
        push @$buffer, { line=>$line, chr=>$chr, pos=>$pos, is_ref=>$is_ref, in_cluster=>0 };
        $n++;

        # Does the buffer hold enough lines now?
        my $last_chr = $$buffer[-1]{chr};
        my $last_pos = $$buffer[-1]{pos};
        for (my $i=$n-1; $i>=0; $i--)
        {
            my $buf = $$buffer[$i];
            if ( $$buf{chr} ne $last_chr ) { $to=$i; last; }
            if ( $last_pos - $$buf{pos} >= $win ) { $to=$i; last; }
        }

        if ( !defined $to ) { return; }
    }
    if ( !defined $to ) { $to=$n-1; }

    # Calculate the number of variants within the window
    my $count = 0;
    my $max_count = $$opts{SnpCluster_count};
    my $start_chr = $$buffer[0]{chr};
    my $start_pos = $$buffer[0]{pos};
    my $idx;
    for ($idx=0; $idx<$n; $idx++)
    {
        my $buf = $$buffer[$idx];
        if ( $$buf{chr} ne $start_chr ) { last; }
        if ( $$buf{pos} - $win >= $start_pos ) { last; }
        if ( !$$buf{is_ref} ) { $count++; }
    }

    # If a SNP cluster was found, set the in_cluster flag for all relevant sites. 
    #   The buffer will be flushed and the orphans would pass unnoticed.
    if ( $count>=$max_count )
    {
        for (my $i=0; $i<$idx; $i++)
        {
            if ( !$$buffer[$i]{is_ref} ) { $$buffer[$i]{in_cluster}=1; }
        }
    }

    # Now output the lines, adding or removing the filter
    for (my $i=0; $i<=$to; $i++)
    {
        my $buf = shift(@$buffer);
        if ( $$buf{in_cluster} )
        {
            $$buf{line}[6] = $$opts{vcf}->add_filter($$buf{line}[6],'SnpCluster'=>1); 
        }
        else
        { 
            $$buf{line}[6] = $$opts{vcf}->add_filter($$buf{line}[6],'SnpCluster'=>0); 
        }
        print_line($$buf{line});
    }

    # Output all non-variant lines at the beggining of the buffer
    while (@$buffer)
    {
        if ( !$$buffer[0]{is_ref} ) { last; }
        my $buf = shift(@$buffer);
        $$buf{line}[6] = $$opts{vcf}->add_filter($$buf{line}[6],'SnpCluster'=>0);
        print_line($$buf{line});
    }
}

sub print_line
{
    my ($line) = @_;
    if ( defined $line ) { print join("\t",@$line) . "\n"; }
}



#---------------------------------

package Reader;

use strict;
use warnings;
use Carp;

sub new
{
    my ($class,@args) = @_;
    my $self = @args ? {@args} : {};
    bless $self, ref($class) || $class;
    if ( !$$self{delim} ) { $$self{delim} = qr/\t/; }
    if ( !$$self{chr} ) { $$self{chr} = 0; }        # the index of the chromosome column (indexed from 0)
    if ( !$$self{from} ) { $$self{from} = 1; }      # the index of the from column 
    if ( !$$self{to} ) { $$self{to} = 2; }          # the index of the to column 
    return $self;
}

sub throw
{
    my ($self,@msg) = @_;
    confess @msg;
}

sub open
{
    my ($self,%args) = @_;
    if ( !$$self{file} ) { return; }
    $self->close();
    open($$self{fh},"tabix $$self{file} $args{region} |") or $self->throw("tabix $$self{file}: $!");
}

sub close
{
    my ($self) = @_;
    if ( !$$self{fh} ) { return; }
    close($$self{fh});
    delete($$self{fh});
    delete($$self{buffer});
}

sub unread_line
{
    my ($self,$line) = @_;
    unshift @{$$self{buffer}}, $line;
    return;
}

sub next_line
{
    my ($self) = @_;
    if ( !$$self{fh} ) { return undef; }    # Run in dummy mode
    if ( $$self{buffer} && @{$$self{buffer}} ) { return shift(@{$$self{buffer}}); }
    my $line;
    # Skip comments
    while (1)
    {
        $line = readline($$self{fh});
        if ( !defined $line ) { return undef; }
        if ( $line=~/^#/ ) { next; }
        last;
    }
    my @items = split($$self{delim},$line);
    return \@items;
}

