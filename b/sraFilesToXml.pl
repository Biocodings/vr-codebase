#!/usr/bin/env perl

# Args should be .fastq files, OR directories that should contain fastq files somewhere
# below. In the latter case, we don't search any subdirectories starting "lib" unless they
# start "libSC".
#
# Switches:
#   -d dir (default "."): directory containing  files
#        (actually just "experiment") and .xsd files
#   -x file1,file2 ...: exclude these files, even if they appear in arguments
#   -X oldDir1,oldDir2,...: 
#   -b badLanes.txt: file of lanes to exclude (e.g. misc/badLanes.txt)

# Switches, defaults, global variables set to (or using) their values, and meanings:
# -A  SRA000303  
#           $ACCESSION_ID (from SRA; default value is for 1000 genomes)
# -C  SC    $CENTER_NAME, $LAB_NAME, $LC_CENTER_NAME
#                      center and lab name (if these are different, we'll have
#                      to tweak the code)
# -I  200   $INSERT_SIZE     insert size
# -T  330   $TILES_PER_LANE  tiles per lane
# -s        $SRC_DIR   source directory (with default.experiment.xml 
#                      and *.xsd files). Defaults depend on -p; see code below
# -t  .     $TGT_DIR   target directory (to write generated XML files to)
# -D  sanger.ac.uk
#           $DOMAIN    domain to go after "@" in contact's e-mail
# -U  $USER environment variable
#                      user name to go before "@" in contact's e-mail
# -M  (now) $SUBMISSION_DATE   submission date to go in files
# -p  g1k   $PROJECT   project (default g1k; can also be sgrp or sal)
# -x        %EXCLUDE   comma-separated list of files to exclude. 
# -X:       %EXCLUDE_BASENAME, %EXCLUDE_EXPERIMENT
#                      comma-separated list of directories oldDir1,oldDir2,...
#                      Look in oldDirN for files named *.submission.xml, and therein
#                      for the pattern filename="...". The "..." are also to be excluded.
#                      Also look in the oldDirN's for *.experiment.xml and the pattern
#                          <LIBRARY_NAME>.*</LIBRARY_NAME>
#                     and exclude those too.
# -b:       %EXCLUDE_BASENAME
#                     file of bad lanes to exclude, e.g. $G1K/misc/badLanes.txt
# -S:       $STAGING_DIR
#                     staging directory (when we have to package up files that
#                     haven't reached the repository yet; hope we never need this again!)
#
# Arguments: fastq and/or fastq.gz files to include, and/or directories
#   (typically a thousand-genomes "DATA" directory, created by updateDataDirectory.pl)
#   to be searched for such files. The resulting list of files is
#   filtered by the values of -b, -x and -X if any.
#
# Typical usage for 1000 genomes:
#
# % ssh cbi4
# % cd /lustre/thougen/thougen/SRA
# % sraFilesToXml.pl -b ../misc/badLanes.txt -X 20080415,20080612 ../DATA
#
# The -X list is of all previous freeze directories, to exclude already-submitted data.
# http://search.cpan.org/dist/XML-Simple/lib/XML/Simple.pm
use XML::Simple;
#use XML::Validator::Schema;
#use XML::SAX::ParserFactory;

use Utility;
use Getopt::Std;
use FileHandle;
use File::Basename;
use strict;

autoflush STDOUT 1;

my %OPT = (A => 'SRA000303',
           C => 'SC',
           D => 'sanger.ac.uk',
           I => 200,
           M => xmlNowString(),
	   p => 'g1k',
	   s => '.',
           t => '.',
           T => 330,
           U => $ENV{USER});
getopts('A:b:C:D:M:p:s:S:t:U:x:X:',\%OPT);

# E-mail address for contact will be $ENV{USER}@$DOMAIN
my $DOMAIN = $OPT{D};
# Fixed header for XML files
my $XML_HEADER = '<?xml version="1.0" encoding="UTF-8"?>';
# Accession ID per project, generated by SRA. SRA000303 is for 
# Sanger's submissions to 1000 genomes.
my $ACCESSION_ID = $OPT{A};
# Center and lab names, upper and lower case, all from -C for now.
my $CENTER_NAME = $OPT{C};
my $LAB_NAME = $CENTER_NAME;
(my $LC_CENTER_NAME = $CENTER_NAME) =~ tr/A-Z/a-z/;
# Numbers from the sequencing process...
my $INSERT_SIZE = $OPT{I};
my $TILES_PER_LANE = $OPT{T};
# Used for submission date:
my $ISO_NOW = $OPT{M};
# Project under which files are being submitted
my $PROJECT = $OPT{p};
# Assume only g1k (and not sgrp or sal) is paired-end
my $READS12 = ($PROJECT eq 'g1k') ? 2 : 1;
# Source directory (for defaults and xsd's)
my $SRC_DIR = $OPT{s};
unless ($SRC_DIR) {
    if ($PROJECT eq 'g1k') {
	$SRC_DIR = '/lustre/thougen/thougen/SRA';
    } elsif ($PROJECT eq 'sgrp') {
	$SRC_DIR = '/lustre/cbi4/work1/sgrp/SRA';
    } elsif ($PROJECT eq 'sal') {
	$SRC_DIR = '/lustre/cbi4/work1/sgrp/SAL/SRA';
    } else {
	die("Don't know what SRC_DIR to use for project $PROJECT");
    }
}
# Target directory
my $TGT_DIR = $OPT{t};

my $STAGING_DIR = $OPT{S};
my %IN_STAGING;
if ($STAGING_DIR) {
    my $fh = new FileHandle("$STAGING_DIR/SOURCES.txt");
    while (<$fh>) {
	chomp;
	if (/srf$/) {
	    s/.*\///;
	    $IN_STAGING{basename($_,'.srf')} = $_;
	}
    }
}	

# Decide files to exclude.
my %EXCLUDE = map {$_ => 1} split(/,/,$OPT{x});
# NOTE: "excluding an experiment" doesn't mean we exclude any new runs
# for it, just that we don't create an experiment.xml file for it.
my (%EXCLUDE_BASENAME,%EXCLUDE_EXPERIMENT);
initializeExcludeBasename($OPT{X},$OPT{b}) if ($OPT{X} || $OPT{b});

# There must be a value of STUDY_NAME for every subproject name;
# see getLaneData for how $pRun->{project} is set for a run.
# (Actually this can't be quite right, because a run _might_ include
# e.g. both trio and low-coverage stuff...)
my %STUDY_NAME = (LowCov => '1000Genomes Project Pilot 1',
		  Trio   => '1000Genomes Project Pilot 2',
                  # For completeness (no exon resequencing at Sanger...)
		  Exon   => '1000Genomes Project Pilot 3',
                  SGRP   => 'SGRP',
		  SAL    => 'Salmonella enterica');

my $XS = XML::Simple->new();
my %OPTS_IN  = (KeepRoot => 1, ForceArray => 1, KeyAttr => []);
my %OPTS_OUT = (KeepRoot => 1, KeyAttr => []);

# Used by expectedBasesForLibrary, see below.
my %TRIO_LIB1_GB = (NA12878 => 27.0,
		    NA12891 => 15.1,
		    NA12892 => 17.7);

# Where problems will be logged (*.problems.txt)
my $LOG_STREAM;

# Off we go...
sraFilesToXml(@ARGV);

sub sraFilesToXml {
    my @files = @_;
    # Preparatory stuff...work out what to include and what to call it
    my $sid = generateSubmissionId();
    $LOG_STREAM = openToWrite("$sid.problems.txt");
    @files = dirsToFastq(@files);
    `mkdir -p $TGT_DIR`;
    my ($pBases,$pSRF) = checkSrfOrFastqFilesExist(fileBases(@files));
    # Generate the XML itself
    sraFilesToXml1($sid,$pBases,$pSRF);
}

# Generate a submission ID from the project, center name and
# date, with a digit suffix to make it "new" in $TGT_DIR.

sub generateSubmissionId {
    my (undef,undef,undef,$day,$mon,$year) = localtime(time());
    my $base = sprintf("%s-%s-%2d%2d%2d-",$PROJECT,
		       $LC_CENTER_NAME,1900+$year,$mon+1,$day);
    $base =~ tr/ /0/;
    my $n = 1; # suffix for uniqueness
    while (1) {
	my $id = "$base$n";
	return $id unless (-s "$TGT_DIR/$id.submission.xml");
	$n ++;
    }
}

# Return every fastq[.gz] file in the list; when a directory is
# encountered, look for fastq[.gz] files in it at any level.

sub dirsToFastq {
    my (@files) = @_;
    my @ans;
    report("searching for .fastq[.gz] files under directories");
    foreach my $f (@files) {
	if (-d $f) {
	    push @ans,fastqUnderDir($f);
	} elsif (isFastqFile($f)) {
	    push @ans,$f;
	} else {	    
	    print $LOG_STREAM "Ignoring argument $f\n";
	}
    }
    report();
    return @ans;
}

sub isFastqFile {
    my ($f) = @_;
    return ($f =~ /\.fastq$/ || $f =~ /\.fastq\.gz$/);
}

sub fastqUnderDir {
    my ($d) = @_;
    my @ans;
    foreach my $f (glob("$d/*")) {
	if (isFastqFile($f)) {
	    push @ans,$f;
	} elsif (-d $f) {
	    my $b = basename($f);
	    if ($b !~ /^lib/ || $b =~ /^libSC/) {
		push @ans,fastqUnderDir($f);
	    }
	}
    }
    return @ans;
}

# Return a list of the "valid" members of @$pBases and another of
# their SRF files (or fastq.gz's). For "valid", see getSrfOrFastq.

sub checkSrfOrFastqFilesExist {
    my ($pBases) = @_;
    my (@ans,@srfList);
    foreach my $b (@$pBases) {
	my ($srf,$ok) = getSrfOrFastq($b);
	if ($ok) {
	    push @srfList,$srf;
	    push @ans,$b;
	} else {
	    print $LOG_STREAM "No SRF file $srf (so not included)\n";
	}
    }
    return (\@ans,\@srfList);
}

# $b should be the name of a fastq file, minus the final .fastq[.gz].

sub getSrfOrFastq {
    my ($b) = @_;
    if ($PROJECT eq 'g1k' || $PROJECT eq 'sal') {
	# In g1k, we expect the fastq file to have an SRF file
	# in the staging directory (if there is one) or itself to
	# be a link to the real thing in a repository directory where
	# there should be an .srf sitting beside it.
	my $bb = basename($b,".srf");
	if ($IN_STAGING{$bb}) {
	    return "$STAGING_DIR/$bb.srf";
	} else {
	    my $srf = readlink("$b.fastq");
	    $srf =~ s/\.fastq$/.srf/;
	    # Return the SRF file name and its size (if any)
	    return ($srf,-s $srf);
	}
    } elsif ($PROJECT eq 'sgrp') {
	# In sgrp, we expect a fastq.gz file to exist (and not
	# be a link). We return it and its size.
	my $fqz = "$b.fastq.gz";
	return ($fqz,-s $fqz);
    }
}

# Return @files without suffixes, and uniquified, and excluding
# "excluded" basenames.

sub fileBases {
    my (@files) = @_;
    my %isBase;
    foreach my $f (@files) {
	unless ($EXCLUDE{$f}) {
	    # Remove everything after and including the
	    # first dot in the basename of $f.
	    while (basename($f) =~ /\./) {
		$f =~ s/\.[^\.]*$//;
	    }
	    $isBase{$f} = 1 unless ($EXCLUDE_BASENAME{basename($f)});
	}
    }
    return [sort keys %isBase];
}

# Having worked out what data files we're going to include, we create
# the actual XML here.

sub sraFilesToXml1 {
    my ($sid,$pBases,$pSRF) = @_;
    my $pLaneData = getLaneData($pBases,$pSRF);
    my $pUserData = getUserData();
    createExperimentXml($sid,$pUserData,$pLaneData);
    createSubmissionXml($sid,$pUserData,$pLaneData);
    createRunXml($sid,$pUserData,$pLaneData);
    createSRFListing($sid,$pSRF);
}

# Given "bases" (whole file names except for final .fastq or whatever) and
# their corresponding SRFs, put together and return per-lane hash structures.

sub getLaneData {
    my ($pBases,$pSRF) = @_;
    my @laneData;
    foreach my $i (0 .. $#$pBases) {
	my $base = $pBases->[$i];
	my $srf  = $pSRF->[$i];
	my $cs = md5sum($srf,$base);
	# Find lots of information in the pathname of $base.
	my (undef,$runAndLane,$lib,$indiv,$projAndPop) = reverse(split("/",$base));
	$lib =~ s/^lib//;
	my ($run,$lane) = ($runAndLane =~ /^lane(\d+)_(\d+)$/);
	my ($proj,$pop);
	if ($PROJECT eq 'sgrp') {
	    $proj = 'SGRP';
	    $pop = $projAndPop;
	} elsif ($PROJECT eq 'sal') {
	    $proj = 'SAL';
	    $pop = $projAndPop;
	} else {
	    ($proj,$pop) = split(/-/,$projAndPop);
	}
	my ($machine,$alias) = getMachineAndAlias("$base.fastq");
	my ($nSpots,$nBases,$rLen) = fastqStats($srf);
	push @laneData,{filename => $srf, 
			checksum => $cs,
			project => $proj,
			population => $pop,
			sample => $indiv,
			library => $lib,
			run => $run,
			read_length => $rLen,
			total_bases => $nBases,
			total_spots => $nSpots,
			total_reads => $nSpots, # was nSpots*2 until 20080611
			machine => $machine,
			alias => $alias,
			lane => $lane,
			srf_date => isoFileDate($srf)};
    }
    return \@laneData;
}

sub md5sum {
    my ($src,$base) = @_;
    (my $tgt1 = $src) =~ s/\..*$/.md5/;
    my $tgt2 = "$base.md5";
    foreach my $tgt ($tgt1,$tgt2) {
	if (-s $tgt) {
	    my $fh = new FileHandle($tgt);
	    while (<$fh>) {
		chomp;
		my ($val,$file) = split;
		return $val if (basename($file) eq basename($src));
	    }
	}
    }
    print $LOG_STREAM "No MD5 file for $src (but included nevertheless)\n";
    return undef;
}

sub getMachineAndAlias {
    my ($fq) = @_;
    if ($PROJECT eq 'sgrp') {
	$fq = "$fq.gz";
    } elsif (-s readlink($fq)) {
	$fq = readlink($fq);
    } elsif ($STAGING_DIR) {
	$fq = sprintf("%s/%s",$STAGING_DIR,basename($fq));
    }
    if (-s $fq) {
	my $fh = openToRead($fq);
	chomp ($_ = <$fh>);
	my ($alias) = split(/:/,substr($_,1));
	my ($machine) = split(/_/,$alias);
	return ($machine,$alias);
    } else {
	die("Cannot find $fq");
    }
}

sub fastqStats {
    my ($f) = @_;
    $f =~ s/\.[^\/]*$/.fastqcheck/; # re-suffix
    if (-s $f) {
	my $fh = new FileHandle($f);
	# Should be e.g.
	# 4259126 sequences, 306657072 total length, 72.00 average, 72 max
	chomp (my $line = <$fh>);
	my ($nSpots,undef,$nBases,undef,undef,$avLen,undef,$maxLen) = split(" ",$line);
	# WAS avLen/2 here before 20080611 ...
	return ($nSpots,$nBases,int(0.5+$avLen));
    } else {
	print $LOG_STREAM "Missing or empty: $f\n";
	return undef;
    }
}

sub isoFileDate {
    my ($f) = @_;
    my @a = stat($f);
    return isoDate($a[9]);
}

sub isoDate {
    my ($t) = @_;
    my ($sec,$min,$hour,$mday,$mon,$year) = localtime($t);
    my $date = sprintf("%4d-%2d-%2dT%2d:%2d:%2d+01:00",
		      $year+1900,$mon+1,$mday,$hour,$min,$sec);
    $date =~ tr/ /0/;
    return $date;
}

sub getUserData {
    my $u = $ENV{USER};
    my @a = getpwnam($u);
    my $name = $a[6];
    $name =~ s/,.*//;
    return {uid => $u,
	    name => $name,
	    mail => "$u\@$DOMAIN"};
}

sub createExperimentXml {
    my ($sid,$pUserData,$pLaneData) = @_;
    my %aliasExample;
    my %excluded;
    foreach my $pH (@$pLaneData) {
	my $lib = $pH->{library};
	$lib =~ s/.*_//;
	my $alias = sprintf("%s-%s-%s-%s-%s",
			    $PROJECT,$LC_CENTER_NAME,$pH->{sample},$pH->{population},$lib);
	if ($EXCLUDE_EXPERIMENT{$alias}) {
	    $excluded{$alias} = 1;
	} else {
	    $aliasExample{$alias} = $pH;
	}
    }
    my @files; # Experiment files created on THIS run, as opposed to already existing.
    my $firstFile; # to use for head and foot
    foreach my $alias (sort keys %aliasExample) {
	my $file = "$TGT_DIR/$alias.experiment.xml";
	$firstFile = $file unless (defined $firstFile);
	if (-s $file) {
	    print "$file: already exists\n";
	} else {
	    reallyCreateExperimentXML($sid,$pUserData,$pLaneData,$alias,$aliasExample{$alias},$file);
	    push @files,$file;
	}
    }
    # If there are no new experiments to be included, we don't need to create an experiment.xml
    # file. When this happens, $firstFile should be undefined and @files should be empty.
    # createExperimentXML1 detects and reports this situation.
    createExperimentXML1($sid,$firstFile,@files);
}

sub reallyCreateExperimentXML {
    my ($sid,$pUserData,$pLaneData,$alias,$pRun,$file) = @_;
    my $pXML = $XS->XMLin("$SRC_DIR/default.experiment.xml",%OPTS_IN);
    my $pExp = $pXML->{EXPERIMENT_SET}[0]{EXPERIMENT}[0];
    my $indiv = $pRun->{sample};
    $pExp->{alias} = $alias;
    my $rl = $pRun->{read_length};
    my $nBases = expectedBasesForLibrary($alias);
    my $nReads = $nBases/$rl;
    $nReads = 1000000*int(0.5+$nReads/1000000); # make it approximate
    my $nSpots = $nReads/$READS12;
    my $nRuns = int(0.5+3*$nSpots/100000000); # approximate only

    $pExp->{expected_number_runs} = $nRuns;
    $pExp->{expected_number_reads} = $nReads;
    $pExp->{expected_number_spots} = $nSpots;

    $pExp->{DESIGN}[0]{LIBRARY_DESCRIPTOR}[0]{LIBRARY_NAME}[0] = $alias;
    if ($READS12 == 2) {
	$pExp->{DESIGN}[0]{LIBRARY_DESCRIPTOR}[0]{LIBRARY_LAYOUT}[0]{PAIRED}[0]{NOMINAL_LENGTH} = $INSERT_SIZE;
    }
    $pExp->{DESIGN}[0]{DESIGN_DESCRIPTION}[0] = 
	$pExp->{DESIGN}[0]{SAMPLE_DESCRIPTOR}[0]{refname} =
	sprintf("Solexa sequencing of Human HapMap individual %s random %s bp library",
		$indiv,$INSERT_SIZE);
    $pExp->{EXPERIMENT_ATTRIBUTES}[0]{EXPERIMENT_ATTRIBUTE} = []; # clear it
    $pExp->{EXPERIMENT_ATTRIBUTES}[0]{EXPERIMENT_ATTRIBUTE}[0]{TAG}[0] = 'center_name';
    $pExp->{EXPERIMENT_ATTRIBUTES}[0]{EXPERIMENT_ATTRIBUTE}[0]{VALUE}[0] = $CENTER_NAME;
    $pExp->{EXPERIMENT_ATTRIBUTES}[0]{EXPERIMENT_ATTRIBUTE}[1]{TAG}[0] = 'expected_number_bases';
    $pExp->{EXPERIMENT_ATTRIBUTES}[0]{EXPERIMENT_ATTRIBUTE}[1]{UNITS}[0] = 'MB';
    my $expMB = int(0.5 + $nBases/1000000);
    $pExp->{EXPERIMENT_ATTRIBUTES}[0]{EXPERIMENT_ATTRIBUTE}[1]{VALUE}[0] = $expMB;
    # This had better be for the reverse read...
    $pExp->{DESIGN}[0]{SPOT_DESCRIPTOR}[0]{SPOT_DECODE_SPEC}[0]{READ_SPEC}[1]{BASE_COORD}[0] = $rl/$READS12+1;
    $pExp->{PLATFORM}[0]{ILLUMINA}[0]{CYCLE_COUNT}[0] = $rl;
    $pExp->{STUDY_REF}[0]{refname} = $STUDY_NAME{$pRun->{project}};
    $pXML->{EXPERIMENT_SET}[0]{EXPERIMENT} = [$pExp];
    xmlToFileAndValidate($pXML,$sid,'experiment',$file);
}

sub expectedBasesForLibrary {
    my ($alias) = @_;
    my ($lib,undef,$indiv) = reverse(split(/-/,$alias));
    my $gb1 = $TRIO_LIB1_GB{$indiv};
    if (!defined $gb1) {
	# should be low-coverage...
	return 7200000000;
    } elsif ($lib == 1 || $lib =~ /_1$/) {
	return $gb1*1000000000;
    } elsif ($lib == 2 || $lib =~ /_2$/) {
	return (38-$gb1)*1000000000;
    } else {
	die("Cannot work out expected bases for $alias");
    }
}

sub xmlToFileAndValidate {
    my ($pXML,$sid,$type,$file) = @_;
    $file = "$TGT_DIR/$sid.$type.xml" unless (defined $file);
    print "$file: creating ... ";
    my $gh = new FileHandle("| reorderXML.pl $SRC_DIR/$type.order.txt > $file");
    xmlToStream($pXML,$gh);
    $gh->close();
    xmlValidate($file,$type);
}

sub xmlToStream {
    my ($pXML,$gh) = @_;
    print $gh "$XML_HEADER\n";
    print $gh $XS->XMLout($pXML,%OPTS_OUT);
}

sub xmlValidate {
    my ($file,$type) = @_;
    print "validating ... ";
    `validateXML.pl $SRC_DIR/SRA.$type.xsd $file >$file.val 2>&1`;
    my $val = "$file.val";
    if (-s $val) {
	print " FAILED:\n";
	my $fh = new FileHandle($val);
	while (<$fh>) {
	    print;
	}
    } else {
	print "done\n";
	unlink($val);
    }
}

sub createExperimentXML1 {
    my ($sid,$firstFile,@files) = @_;
    my $file = "$TGT_DIR/$sid.experiment.xml";
    return if (-s $file);
    if (defined $firstFile) {
	print "$file: creating ...";
	`head -2 $firstFile > $file`;
	my $gh = new FileHandle(">>$file");
	foreach my $f (@files) {
	    my $fh = new FileHandle($f);
	    while (<$fh>) {
		print $gh $_ unless (/^</);
	    }
	}
	`tail -1 $firstFile >> $file`;
	xmlValidate($file,'experiment');
	foreach my $f (@files) {
	    unlink($f);
	}
    } elsif (@files) {
	die("\@files but no \$firstFile -- should never happen...");
    } else {
	print "$file: not required because no new experiments\n";
    }
	
}

sub createSubmissionXml {
    my ($sid,$pUserData,$pLaneData) = @_;
    my $pXML = $XS->XMLin('<SUBMISSION></SUBMISSION>',%OPTS_IN);
    my $pXML0 = $pXML->{SUBMISSION}[0];
    $pXML0->{'xmlns:xsi'} = "http://www.w3.org/2001/XMLSchema-instance";
    #$pXML0->{'xsi:noNamespaceSchemaLocation'} = "http://www.ncbi.nlm.nih.gov/Traces/sra/static/SRA.submission.xsd";
    $pXML0->{accession} = $ACCESSION_ID;
    $pXML0->{handle} = '.';
    $pXML0->{submission_id} = $sid;
    $pXML0->{submission_date} = $ISO_NOW;
    my $script = basename($0);
    $pXML0->{submission_comment} = 
	"ftp submission prepared by $pUserData->{mail} using $script";
    $pXML0->{center_name} = $CENTER_NAME;
    $pXML0->{lab_name} = $LAB_NAME;
    $pXML0->{CONTACTS}[0]{CONTACT}[0]{name} = $pUserData->{name};
    $pXML0->{CONTACTS}[0]{CONTACT}[0]{inform_on_status} = $pUserData->{mail};
    $pXML0->{CONTACTS}[0]{CONTACT}[0]{inform_on_error} = $pUserData->{mail};
    $pXML0->{ACTIONS}[0]{ACTION}[0]{ADD} = [];
    $pXML0->{ACTIONS}[0]{ACTION}[0]{ADD}[0]{source} = "$sid.run.xml";
    $pXML0->{ACTIONS}[0]{ACTION}[0]{ADD}[0]{schema} = "run";
    $pXML0->{ACTIONS}[0]{ACTION}[0]{ADD}[0]{notes} = "runs wrapper";
    $pXML0->{ACTIONS}[0]{ACTION}[1]{ADD}[0]{source} = "$sid.experiment.xml";
    $pXML0->{ACTIONS}[0]{ACTION}[1]{ADD}[0]{schema} = "experiment";
    $pXML0->{ACTIONS}[0]{ACTION}[1]{ADD}[0]{notes} = "experiment descriptor";
    my @fileArray;
    foreach my $pH (@$pLaneData) {
	push @fileArray,{filename => basename($pH->{filename}),
			 checksum_method => 'MD5',
			 checksum => $pH->{checksum}};
    }
    $pXML0->{FILES}[0]{FILE} = \@fileArray;
    xmlToFileAndValidate($pXML,$sid,'submission');
}

sub createRunXml {
    my ($sid,$pUserData,$pLaneData) = @_;
    my $pXML = $XS->XMLin('<RUN_SET></RUN_SET>',%OPTS_IN);
    my $pXML0 = $pXML->{RUN_SET}[0];
    $pXML0->{'xmlns:xsi'} = "http://www.w3.org/2001/XMLSchema-instance";
    #$pXML0->{'xsi:noNamespaceSchemaLocation'} = "http://www.ncbi.nlm.nih.gov/Traces/sra/static/SRA.run.xsd";
    my %lanesByRun;
    foreach my $pH (@$pLaneData) {
	my $lib = $pH->{library};
	$lib =~ s/.*_//;
	push @{$lanesByRun{sprintf(join(".",$pH->{run},$pH->{sample},$lib))}},$pH;
    }
    my @runs;
    foreach my $pLanes (values %lanesByRun) {
	my $pRun = {};
	my $pH0 = $pLanes->[0]; # use first one for %attrs
	my $pRun = {alias => join("_",$pH0->{alias},$pH0->{sample}),
		    instrument_model => "Solexa 1G Genome Analyzer",
		    instrument_name => $pH0->{machine},
		    run_date => $pH0->{srf_date} || die("No srf_date for $pH0->{run}_$pH0->{lane}"),
		    run_center => $CENTER_NAME,
		    # We don't set this, as we have a different file for each block...
		    #run_file => basename($pH0->{filename}),
		    total_data_blocks => scalar(@$pLanes)};
	my $lib = $pH0->{library};
	$lib =~ s/.*_//;
	$pRun->{EXPERIMENT_REF}[0]{refname} = 
	    join("-",$PROJECT,$LC_CENTER_NAME,$pH0->{sample},$pH0->{population},$lib);
	my @dbList;
	my $totalBases = 0;
	foreach my $pH (@$pLanes) {
	    my %db = (name => sprintf("%s_%s",$pH->{alias},$pH->{lane}),
		      sector => $pH->{lane},
		      region => 0, # !! check this
		      total_spots => $pH->{total_spots},
		      total_reads => $pH->{total_reads},
		      number_channels => 4,
		      format_code => 1);
            $totalBases += $pH->{total_bases};
            $db{FILES}[0]{FILE}[0]{filename} = basename($pH->{filename});
            $db{FILES}[0]{FILE}[0]{filetype} = 'srf';
            push @dbList,\%db;
        }
        $pRun->{DATA_BLOCK} = \@dbList;
        my @runAttrs;
        $runAttrs[0] = {TAG => ['actual_read_length'], VALUE => [$pH0->{read_length}]};
        $runAttrs[1] = {TAG => ['run'], VALUE => [$pH0->{run}]};
        $runAttrs[2] = {TAG => ['total_bases'], VALUE => [$totalBases], UNITS => ['bp']};
        $pRun->{RUN_ATTRIBUTES}[0]{RUN_ATTRIBUTE} = \@runAttrs;
        push @runs,$pRun;
    }
    $pXML0->{RUN} = \@runs;
    xmlToFileAndValidate($pXML,$sid,'run',);
}

sub createSRFListing {
    my ($sid,$pSRF) = @_;
    my $gh = openToWrite("$sid.srf_manifest.txt");
    foreach my $f (@$pSRF) {
	print $gh "$f\n";
    }
    $gh->close();
}

sub copyArray {
    my ($pA1) = @_;
    my $pA2 = [];
    foreach my $i (0 .. $#$pA1) {
	my $val = $pA1->[$i];
	$pA2->[$i] = copyValue($val);
    }
    return $pA2;
}

sub copyValue {
    my ($x) = @_;
    my $r = ref($x);
    if ($r eq 'ARRAY') {
	return copyArray($x);
    } elsif ($r eq 'HASH') {
	return copyHash($x);
    } else {
	return $x;
    }
}

sub copyHash {
    my ($pH1) = @_;
    my $pH2 = {};
    foreach my $key (keys %$pH1) {
	my $val = $pH1->{$key};
	$pH2->{$key} = copyValue($val);
    }
    return $pH2;
}

sub initializeExcludeBasename {
    my ($pat,$badLaneFile) = @_;
    report("finding basenames and experiments to exclude");
    if ($pat) {
	foreach my $dir (split(",",$pat)) {
	    foreach my $f (glob("$dir/*.submission.xml")) {
		my $fh = openToRead($f);
		while (<$fh>) {
		    if (/filename="([^"]+)"/) {
			my $base = $1;
			$base =~ s/\.[^\.]*$//;
			$EXCLUDE_BASENAME{$base} = 1;
		    }
		}
	    }
	    foreach my $f (glob("$dir/*.experiment.xml")) {
		my $fh = openToRead($f);
		while (<$fh>) {
		    if (/<LIBRARY_NAME>(.*)<\/LIBRARY_NAME>/) {
			$EXCLUDE_EXPERIMENT{$1} = 1;
		    }
		}
	    }
	}
	
    }
    if ($badLaneFile) {
	my $fh = openToRead($badLaneFile);
	while (<$fh>) {
	    chomp;
	    if (/^lane(\d+)_\.$/) {
		my $run = $1;
		foreach my $n (1 .. 8) {
		    $EXCLUDE_BASENAME{"${run}_s_$n"} = 1;
		}
	    } elsif (/^lane(\d+)_(\d)$/) {
		my ($run,$pos) = ($1,$2);
		$EXCLUDE_BASENAME{"${run}_s_$pos"} = 1;
	    }
	}
    }
    my $n1 = scalar(keys %EXCLUDE_BASENAME);
    my $n2 = scalar(keys %EXCLUDE_EXPERIMENT);
    print "found $n1 and $n2 ... ";
    report();
}

sub xmlNowString {
    return isoDate(time());
}
